"""
Tmuxinator integration for per-project workers sessions.

This module provides functionality to create and manage per-project tmux sessions
using tmuxinator. Each project gets its own workers session (e.g., workers-orch-cli,
workers-beads) with a pinned 'servers' window for development servers.
"""

import subprocess
from pathlib import Path
from typing import Optional


# Template for tmuxinator config with pinned servers window
WORKERS_TEMPLATE = """# Auto-generated by orch spawn
# Per-project workers session for {project_name}
name: workers-{project_name}
root: {project_dir}

# Start focused on servers window (for dev servers)
startup_window: servers

windows:
  - servers:
      root: {project_dir}
      panes:
        - # Dev servers (npm run dev, etc.)
"""


def session_exists(session_name: str) -> bool:
    """
    Check if a tmux session exists.

    Args:
        session_name: Name of the tmux session to check

    Returns:
        True if session exists, False otherwise
    """
    from orch.tmux_utils import find_session
    return find_session(session_name) is not None


def ensure_tmuxinator_config(project_name: str, project_dir: Path) -> Path:
    """
    Ensure tmuxinator config exists for project, creating if needed.

    Creates a tmuxinator YAML config file that defines a workers session
    with a pinned 'servers' window at position 0 for development servers.

    Args:
        project_name: Name of the project (used in session name)
        project_dir: Path to the project directory

    Returns:
        Path to the tmuxinator config file
    """
    config_dir = Path.home() / ".tmuxinator"
    config_dir.mkdir(parents=True, exist_ok=True)

    config_path = config_dir / f"workers-{project_name}.yml"

    if not config_path.exists():
        config_content = WORKERS_TEMPLATE.format(
            project_name=project_name,
            project_dir=str(project_dir)
        )
        config_path.write_text(config_content)

    return config_path


def start_workers_session(project_name: str) -> bool:
    """
    Start workers session via tmuxinator if not already running.

    Creates a new tmux session with the per-project workers configuration.
    If session already exists, returns True without starting new one.

    Args:
        project_name: Name of the project (session will be workers-{project_name})

    Returns:
        True if session is running (either started or already existed),
        False if session creation failed
    """
    session_name = f"workers-{project_name}"

    # Check if session already running
    if session_exists(session_name):
        return True

    # Start via tmuxinator in detached mode
    result = subprocess.run(
        ["tmuxinator", "start", session_name, "-d"],
        capture_output=True,
        text=True
    )

    return result.returncode == 0


def _get_current_client_tty() -> Optional[str]:
    """
    Get the TTY of the current tmux client (the one running this process).

    Returns:
        TTY path (e.g., '/dev/ttys000') or None if not in tmux
    """
    result = subprocess.run(
        ["tmux", "display-message", "-p", "#{client_tty}"],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        return None
    tty = result.stdout.strip()
    return tty if tty else None


def get_orchestrator_current_project() -> Optional[str]:
    """
    Get the project name the orchestrator session is currently working in.

    Checks the current pane's working directory in the orchestrator session
    and extracts the project name from the path.

    Returns:
        Project name (e.g., 'orch-cli') or None if can't determine
    """
    result = subprocess.run(
        ["tmux", "display-message", "-t", "orchestrator", "-p", "#{pane_current_path}"],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        return None

    cwd = result.stdout.strip()
    if not cwd:
        return None

    # Extract project name from path (last component of git root or cwd)
    # Try to find .git to identify project root
    path = Path(cwd)
    while path != path.parent:
        if (path / '.git').exists():
            return path.name
        path = path.parent

    # Fallback to directory name
    return Path(cwd).name


def switch_workers_client(session_name: str, check_orchestrator_context: bool = False) -> bool:
    """
    Switch the workers tmux client to a different session.

    Finds the client attached to any workers session (excluding the current
    client) and switches it to the specified session. This allows the
    Ghostty window to automatically show the correct project's workers session.

    The current client is excluded to prevent the orchestrator from accidentally
    switching itself when it happens to be attached to a workers session.

    Args:
        session_name: Target session name (e.g., 'workers-orch-cli')
        check_orchestrator_context: If True, only switch if orchestrator is
            still in the same project. Prevents race conditions when user
            quickly switches orchestrator context after spawning.

    Returns:
        True if switch succeeded, False if no workers client found,
        switch failed, or orchestrator context doesn't match
    """
    # Check orchestrator context if requested (prevents race condition)
    if check_orchestrator_context:
        # Extract project name from session_name (e.g., 'workers-orch-cli' -> 'orch-cli')
        if session_name.startswith('workers-'):
            target_project = session_name[8:]  # Remove 'workers-' prefix
        else:
            target_project = session_name

        orchestrator_project = get_orchestrator_current_project()
        if orchestrator_project and orchestrator_project != target_project:
            # Orchestrator has switched to a different project - skip the switch
            # This prevents disrupting the user who has already moved on
            return False

    # Get current client TTY to exclude it from selection
    # This prevents the orchestrator from switching itself
    current_client_tty = _get_current_client_tty()

    # FAIL-SAFE: If we can't determine current client, don't switch anyone
    # This prevents accidentally switching the orchestrator if tmux display-message fails
    if not current_client_tty:
        return False

    # Find any workers client by looking for clients attached to workers* sessions
    # We need to get the TTY of the client that's showing workers content
    result = subprocess.run(
        ["tmux", "list-clients", "-F", "#{client_tty} #{session_name}"],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        return False

    # Parse output to find workers client (excluding current client)
    workers_client_tty = None
    for line in result.stdout.strip().split('\n'):
        if not line:
            continue
        parts = line.split(' ', 1)
        if len(parts) == 2:
            tty, session = parts
            # Skip the current client to avoid switching the orchestrator
            # Note: current_client_tty is guaranteed non-None due to fail-safe above
            if tty == current_client_tty:
                continue
            if session.startswith('workers'):
                workers_client_tty = tty
                break

    if not workers_client_tty:
        # No workers client attached - this is not an error, just skip switch
        return False

    # Switch the workers client to the new session
    switch_result = subprocess.run(
        ["tmux", "switch-client", "-c", workers_client_tty, "-t", session_name],
        capture_output=True,
        text=True
    )

    return switch_result.returncode == 0


def get_workers_client_tty(exclude_current: bool = True) -> Optional[str]:
    """
    Get the TTY of the client attached to a workers session.

    Searches for any tmux client attached to a session starting with 'workers'
    and returns its TTY path. By default, excludes the current client to avoid
    returning the orchestrator when it happens to be on a workers session.

    Args:
        exclude_current: If True, exclude the current client from search.
                        Default True to prevent orchestrator self-selection.

    Returns:
        TTY path (e.g., '/dev/ttys043') or None if no workers client found
    """
    # Get current client TTY to optionally exclude it
    current_client_tty = _get_current_client_tty() if exclude_current else None

    # FAIL-SAFE: If exclusion requested but can't determine current client, return None
    # This prevents returning potentially wrong client (e.g., orchestrator on workers session)
    if exclude_current and not current_client_tty:
        return None

    result = subprocess.run(
        ["tmux", "list-clients", "-F", "#{client_tty} #{session_name}"],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        return None

    for line in result.stdout.strip().split('\n'):
        if not line:
            continue
        parts = line.split(' ', 1)
        if len(parts) == 2:
            tty, session = parts
            # Skip the current client if exclusion is enabled
            if current_client_tty and tty == current_client_tty:
                continue
            if session.startswith('workers'):
                return tty

    return None
