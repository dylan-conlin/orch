"""
Tmuxinator integration for per-project workers sessions.

This module provides functionality to create and manage per-project tmux sessions
using tmuxinator. Each project gets its own workers session (e.g., workers-orch-cli,
workers-beads) with a pinned 'servers' window for development servers.
"""

import subprocess
from pathlib import Path
from typing import Optional


# Template for tmuxinator config with pinned servers window
WORKERS_TEMPLATE = """# Auto-generated by orch spawn
# Per-project workers session for {project_name}
name: workers-{project_name}
root: {project_dir}

# Start focused on servers window (for dev servers)
startup_window: servers

windows:
  - servers:
      root: {project_dir}
      panes:
        - # Dev servers (npm run dev, etc.)
"""


def session_exists(session_name: str) -> bool:
    """
    Check if a tmux session exists.

    Args:
        session_name: Name of the tmux session to check

    Returns:
        True if session exists, False otherwise
    """
    from orch.tmux_utils import find_session
    return find_session(session_name) is not None


def ensure_tmuxinator_config(project_name: str, project_dir: Path) -> Path:
    """
    Ensure tmuxinator config exists for project, creating if needed.

    Creates a tmuxinator YAML config file that defines a workers session
    with a pinned 'servers' window at position 0 for development servers.

    Args:
        project_name: Name of the project (used in session name)
        project_dir: Path to the project directory

    Returns:
        Path to the tmuxinator config file
    """
    config_dir = Path.home() / ".tmuxinator"
    config_dir.mkdir(parents=True, exist_ok=True)

    config_path = config_dir / f"workers-{project_name}.yml"

    if not config_path.exists():
        config_content = WORKERS_TEMPLATE.format(
            project_name=project_name,
            project_dir=str(project_dir)
        )
        config_path.write_text(config_content)

    return config_path


def start_workers_session(project_name: str) -> bool:
    """
    Start workers session via tmuxinator if not already running.

    Creates a new tmux session with the per-project workers configuration.
    If session already exists, returns True without starting new one.

    Args:
        project_name: Name of the project (session will be workers-{project_name})

    Returns:
        True if session is running (either started or already existed),
        False if session creation failed
    """
    session_name = f"workers-{project_name}"

    # Check if session already running
    if session_exists(session_name):
        return True

    # Start via tmuxinator in detached mode
    result = subprocess.run(
        ["tmuxinator", "start", session_name, "-d"],
        capture_output=True,
        text=True
    )

    return result.returncode == 0


def _get_current_client_tty() -> Optional[str]:
    """
    Get the TTY of the current tmux client (the one running this process).

    Returns:
        TTY path (e.g., '/dev/ttys000') or None if not in tmux
    """
    result = subprocess.run(
        ["tmux", "display-message", "-p", "#{client_tty}"],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        return None
    tty = result.stdout.strip()
    return tty if tty else None


def switch_workers_client(session_name: str) -> bool:
    """
    Switch the workers tmux client to a different session.

    Finds the client attached to any workers session (excluding the current
    client) and switches it to the specified session. This allows the
    Ghostty window to automatically show the correct project's workers session.

    The current client is excluded to prevent the orchestrator from accidentally
    switching itself when it happens to be attached to a workers session.

    Args:
        session_name: Target session name (e.g., 'workers-orch-cli')

    Returns:
        True if switch succeeded, False if no workers client found
        or switch failed
    """
    # Get current client TTY to exclude it from selection
    # This prevents the orchestrator from switching itself
    current_client_tty = _get_current_client_tty()

    # Find any workers client by looking for clients attached to workers* sessions
    # We need to get the TTY of the client that's showing workers content
    result = subprocess.run(
        ["tmux", "list-clients", "-F", "#{client_tty} #{session_name}"],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        return False

    # Parse output to find workers client (excluding current client)
    workers_client_tty = None
    for line in result.stdout.strip().split('\n'):
        if not line:
            continue
        parts = line.split(' ', 1)
        if len(parts) == 2:
            tty, session = parts
            # Skip the current client to avoid switching the orchestrator
            if current_client_tty and tty == current_client_tty:
                continue
            if session.startswith('workers'):
                workers_client_tty = tty
                break

    if not workers_client_tty:
        # No workers client attached - this is not an error, just skip switch
        return False

    # Switch the workers client to the new session
    switch_result = subprocess.run(
        ["tmux", "switch-client", "-c", workers_client_tty, "-t", session_name],
        capture_output=True,
        text=True
    )

    return switch_result.returncode == 0


def get_workers_client_tty(exclude_current: bool = True) -> Optional[str]:
    """
    Get the TTY of the client attached to a workers session.

    Searches for any tmux client attached to a session starting with 'workers'
    and returns its TTY path. By default, excludes the current client to avoid
    returning the orchestrator when it happens to be on a workers session.

    Args:
        exclude_current: If True, exclude the current client from search.
                        Default True to prevent orchestrator self-selection.

    Returns:
        TTY path (e.g., '/dev/ttys043') or None if no workers client found
    """
    # Get current client TTY to optionally exclude it
    current_client_tty = _get_current_client_tty() if exclude_current else None

    result = subprocess.run(
        ["tmux", "list-clients", "-F", "#{client_tty} #{session_name}"],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        return None

    for line in result.stdout.strip().split('\n'):
        if not line:
            continue
        parts = line.split(' ', 1)
        if len(parts) == 2:
            tty, session = parts
            # Skip the current client if exclusion is enabled
            if current_client_tty and tty == current_client_tty:
                continue
            if session.startswith('workers'):
                return tty

    return None
